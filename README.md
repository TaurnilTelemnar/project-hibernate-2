GO src/main/java/app/Runner.java to RUN Application

Замечания:
1. Связи "film -M---M- category" и "film -M---M- actor". В задаче они позиционируются как 
"Многие ко многим", но есть нюанс. Промежуточные таблички "film_actor" и "film_category" в базе
имеют поле "last_update". В вашем же собственном https://youtu.be/QIdL2bZI4jY?t=1123 разборе ментор 
по этой самой причине выделил inventory в отдельный объект, создав две связи ManyToOne:
"film -1---M- inventory" и "inventory -M---1- store". Получается неоднозначность трактовки.
2. Связь "customer -M---1- store".
В контексте "В магазин пришел покупатель" она справедлива
(будет странно, если один покупатель одновременно придет в два магазина). Но здесь,
если разобраться, эта связь описывает ситуацию "Покупатель - это клиент магазина".
Ровно также, как, скажем, у меня есть карта лояльности магазина. И у меня может быть 
много таких карт. А у магазина может быть много таких покупателей с картами.

Эта парадигма основывается на связанном событии - аренда. Событие хранится в базе всегда.
Следовательно, основное предназначение события аренды - отслеживать кто из покупателей
и когда взял и вернул(или не вернул) инвентарь(экземпляр фильма). Это отслеживание выходит за рамки одного
посещения одного и того же магазина одним и тем же покупателем - очевидно, что речь идет 
минимум о двух посещениях одного и того же магазина одним и тем же покупателем.
Тут необходимо немного расширить понимание, и отвязать ту часть деятельности человека,
которая рассматривается в контексте "Покупатель или Клиент".


Ввести сущность human, например. Где будут содержаться все люди.
Да, тогда придется Actor и Staff тоже привязать к людям, иначе будет странно.
   А если всего этого не сделать, то получается, что покупатель гвоздями приколочен к одному магазину,
   и в другой магазин тот же самый покупатель без костылей вообще никак не сможет сходить.

Добавить таблицу:
- human

Ввести связи: 
- "human -M---1- customer" и "customer -M---1- store" (вот эта штука позволит обойти ограничение)
- "human -M---1- staff"
- "human -M---1- actor"

3. Идеологическая ошибка в предметной области объектной модели. https://youtu.be/QvfmO82iV98?t=4504
здесь ментор представляет Inventory как факт того, что Film был сдан в аренду.
Но если разобраться в предметной области поглубже, то Inventory олицетворяет собой
не что иное, как экземпляр фильма, копию, коробку с DVD-диском, если проще. Это физическая реализация
абстракции типа фильм. Нельзя сдать в аренду сам фильм непосредственно - он нематериален. Можно сдать только его копию, которая имеет
реализацию в виде диска с записью фильма.

Ошибка заключается в рассуждении: "...то есть, если у нас есть фильм, например, id`шка 123, но инвентаря под
этот фильм нет, то есть, этот фильм еще ни разу не сдавался, то тогда такой фильм мы можем сдать в аренду...". 
В реальности, отсутствие инвентаря у фильма означает, что отсутствует носитель с этим фильмом. В контексте магазина - 
отсутствует экземпляр фильма, который можно сдать. 

**Резюме: отсутствие инвентаря у фильма НЕ означает, что такой фильм мы можем сдать в аренду.
Отсутствие инвентаря у фильма означает, что такой фильм в аренду сдать по определению НЕЛЬЗЯ.
Допущена кардинальная ошибка - следовало искать связь между Inventory и Rental, вместо этого
ищется связь между Film и Inventory.**

В контексте этой ошибки, ментор осознанно упрощает запрос из "То есть либо в rental не должно быть вообще записей по инвентарю, 
либо должна быть заполнена колонка return_date таблицы rental
для последней аренды этого инвентаря." в "То есть в rental не должно быть вообще записей по инвентарю".
Вот это место: https://youtu.be/QvfmO82iV98?t=4721

"...одному и тому же фильму может соответствовать несколько записей инвентаря, нам нужно выбирать последнюю запись..."

Inventory - это диск с фильмом. Не имеет значения, какой у него lastUpdate - это же, по сути, дата производства.
Объект Rental - вот это непосредственно событие аренды для Inventory. И именно Rental необходимо
искать в таком контексте (самое последнее по дате). Самый поздний факт аренды диска с фильмом
как раз и укажет, был возвращен диск по факту, или нет. Соответственно, доступен Inventory для аренды, или нет.

Дальше выполняется запрос фильма по фильтру "любой уникальный ID фильма, для которого нет Inventory".
То есть, по факту, выбирается фильм, диска с которым не существует.
Затем производится создание Inventory по найденному фильму. Считается, что таким способом фильм сдается в аренду.
По факту происходит создание нового экземпляра фильма и сдача его в аренду.

***Это абсолютно не соответствует условию задачи.***

Далее. Из п.2 мы помним, что Customer гвоздями прибит к Store. Customer прилетает на вход метода. Метода, который
демонстрирует ментор. Нужно взять Store из Customer`а - раз уж в контексте базы так задумано. По факту Store 
достается из базы. В этом случае достается тот же самый, что у Customer. Но это еще одна логическая ошибка. Стоит 
перепутать Store - и получится, что у нас покупатель, не являющийся клиентом магазина, берет в аренду диск с фильмом.



Запрос, который удовлетворяет условию задачи:

            Query<Inventory> inventoryQuery = session.createQuery(
                    "SELECT i FROM Inventory i " +
                            "WHERE i.inventoryId NOT IN " +
                            "(SELECT r.inventory.inventoryId FROM Rental r " +
                            "WHERE r.returnDate IS NULL)", Inventory.class);

Выбрать Inventory(диск с фильмом), у которого отсутствует связь с Rental(арендой), где у
Rental(аренды) отсутствует дата возврата.
Этот запрос покрывает оба кейса в задаче: будет выбран Inventory, который не связан
ни с одной активной арендой, и Inventory, у которого вообще нет и не было ни одной аренды.

4. Вот тут даже подсказка в условии задачи есть - фильм должен быть доступен для аренды https://youtu.be/QvfmO82iV98?t=5318.
Что как бэ явно намекает - у фильма должно существовать хотя бы одно Inventory. Иначе как еще
можно ограничить сдачу фильма в аренду, опираясь на связи в предметной области? Мы же не считаем,
что все клиенты смотрят один и тот же диск с фильмом - явно у магазина экземпляров каждого фильма
больше. Как понимает это ментор? Да... в общем-то, никак. Просто создал фильм, и все на этом.
- Film - это абстракция, указатель на что-то нематериальное.
- Inventory - это экземпляр, физическая реализация фильма. Диск DVD, например.
- Rental - событие аренды для конкретного Inventory.

Когда происходит событие "Покупатель пришел в магазин и арендовал фильм", то это 
в объектной модели выглядит так:
- выбрали Inventory, для которого нет открытых Rental, или нет Rental вообще
- создали новый Rental и связанный с ним Payment
- Inventory теперь считается недоступным для аренды, т.к. имеет открытый Rental

Когда происходит событие "Покупатель пришел в магазин и вернул арендованный фильм", то это
в объектной модели выглядит так:
- нашли Rental по Inventory, с которым пришел покупатель
- закрыли Rental(проставили returnDate)
- Inventory теперь считается доступным для аренды, т.к. у него опять нет открытых Rental

  5. Уникальные значения в таблицах. Конечно, если добавить проверки на уровне базы,
  это серьезно усложнит задачу. Но не обратить на это внимание просто невозможно.
  Решительно все имена - городов, стран, имена покупателей, названия фильмов и вообще все,
  что являет собой естественный ключ,- НЕ УНИКАЛЬНЫ. Можно создать сколь угодно много
  Василиев Пупкиных, отличать которые будет только их ID. Можно создавать до посинения 
  условно-бесконечное множество "русских языков" в Language, или стран с именем "Gonduras" 
  в Country - и это прокатит.
     6. "Два поля в Entity ссылались на одно поле базы данных" https://youtu.be/QvfmO82iV98?t=6117.
     В шестом гибере эта проблема отсутствует - можно задать в качестве ID поле другой сущности, 
     с которой установлена связь OneToOne.
     Вот так работает:

               @Id
               @JoinColumn(name = "film_id")
               @OneToOne()
               private Film film;

